/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports2, module2) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0) return names;
      for (name in events = this._events) {
        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.addListener = EventEmitter.prototype.on;
    EventEmitter.prefixed = prefix;
    EventEmitter.EventEmitter = EventEmitter;
    if ("undefined" !== typeof module2) {
      module2.exports = EventEmitter;
    }
  }
});

// node_modules/obsidian-dev-utils/dist/lib/Error.cjs
var require_Error = __commonJS({
  "node_modules/obsidian-dev-utils/dist/lib/Error.cjs"(exports2, module2) {
    (function patchRequireEsmDefault() {
      const __require = require;
      require = Object.assign((id) => {
        const module3 = __require(id);
        return module3.__esModule && module3.default ? module3.default : module3;
      }, __require);
    })();
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var Error_exports = {};
    __export2(Error_exports, {
      emitAsyncErrorEvent: () => emitAsyncErrorEvent,
      errorToString: () => errorToString,
      getStackTrace: () => getStackTrace,
      printError: () => printError,
      registerAsyncErrorEventHandler: () => registerAsyncErrorEventHandler,
      throwExpression: () => throwExpression
    });
    module2.exports = __toCommonJS2(Error_exports);
    var import_eventemitter3 = require_eventemitter3();
    var ASYNC_ERROR_EVENT = "asyncError";
    var asyncErrorEventEmitter = new import_eventemitter3.EventEmitter();
    asyncErrorEventEmitter.on(ASYNC_ERROR_EVENT, handleAsyncError);
    function emitAsyncErrorEvent(asyncError) {
      asyncErrorEventEmitter.emit(ASYNC_ERROR_EVENT, asyncError);
    }
    function errorToString(error) {
      return parseErrorEntries(error).map((entry) => "  ".repeat(entry.level) + entry.message).join("\n");
    }
    function getStackTrace() {
      const stack = new Error().stack ?? "";
      const lines = stack.split("\n");
      return lines.slice(2).join("\n");
    }
    function printError(error) {
      const entries = parseErrorEntries(error);
      for (const entry of entries) {
        if (entry.shouldClearAnsiSequence) {
          console.error(`\x1B[0m${entry.message}\x1B[0m`);
        } else {
          console.error(entry.message);
        }
      }
    }
    function registerAsyncErrorEventHandler(handler) {
      asyncErrorEventEmitter.on(ASYNC_ERROR_EVENT, handler);
      return () => asyncErrorEventEmitter.off(ASYNC_ERROR_EVENT, handler);
    }
    function throwExpression(error) {
      throw error;
    }
    function handleAsyncError(asyncError) {
      printError(new Error("An unhandled error occurred executing async operation", { cause: asyncError }));
    }
    function parseErrorEntries(error, level = 0, entries = []) {
      if (error === void 0) {
        return entries;
      }
      if (!(error instanceof Error)) {
        let str = "";
        if (error === null) {
          str = "(null)";
        } else if (typeof error === "string") {
          str = error;
        } else {
          str = JSON.stringify(error);
        }
        entries.push({ level, message: str });
        return entries;
      }
      const title = `${error.name}: ${error.message}`;
      entries.push({ level, message: title, shouldClearAnsiSequence: true });
      if (error.stack) {
        const restStack = error.stack.startsWith(title) ? error.stack.slice(title.length + 1) : error.stack;
        entries.push({ level, message: `Error stack:
${restStack}` });
      }
      if (error.cause !== void 0) {
        entries.push({ level, message: "Caused by:" });
        parseErrorEntries(error.cause, level + 1, entries);
      }
      return entries;
    }
  }
});

// node_modules/obsidian-dev-utils/dist/lib/Async.cjs
var require_Async = __commonJS({
  "node_modules/obsidian-dev-utils/dist/lib/Async.cjs"(exports2, module2) {
    (function patchRequireEsmDefault() {
      const __require = require;
      require = Object.assign((id) => {
        const module3 = __require(id);
        return module3.__esModule && module3.default ? module3.default : module3;
      }, __require);
    })();
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var Async_exports = {};
    __export2(Async_exports, {
      addErrorHandler: () => addErrorHandler,
      asyncFilter: () => asyncFilter,
      asyncFlatMap: () => asyncFlatMap,
      asyncMap: () => asyncMap,
      convertAsyncToSync: () => convertAsyncToSync,
      convertSyncToAsync: () => convertSyncToAsync,
      invokeAsyncSafely: () => invokeAsyncSafely,
      marksAsTerminateRetry: () => marksAsTerminateRetry,
      retryWithTimeout: () => retryWithTimeout2,
      runWithTimeout: () => runWithTimeout,
      sleep: () => sleep2,
      timeout: () => timeout,
      toArray: () => toArray
    });
    module2.exports = __toCommonJS2(Async_exports);
    var import_Error = require_Error();
    async function addErrorHandler(asyncFn) {
      try {
        await asyncFn();
      } catch (asyncError) {
        (0, import_Error.emitAsyncErrorEvent)(asyncError);
      }
    }
    async function asyncFilter(arr, predicate) {
      const predicateResults = await asyncMap(arr, predicate);
      return arr.filter((_, index) => predicateResults[index]);
    }
    async function asyncFlatMap(arr, callback) {
      return (await asyncMap(arr, callback)).flat();
    }
    async function asyncMap(arr, callback) {
      return await Promise.all(arr.map(callback));
    }
    function convertAsyncToSync(asyncFunc) {
      return (...args) => {
        invokeAsyncSafely(() => asyncFunc(...args));
      };
    }
    function convertSyncToAsync(syncFn) {
      return (...args) => Promise.resolve().then(() => syncFn(...args));
    }
    function invokeAsyncSafely(asyncFn) {
      void addErrorHandler(asyncFn);
    }
    function marksAsTerminateRetry(error) {
      return Object.assign(error, { __terminateRetry: true });
    }
    async function retryWithTimeout2(fn, retryOptions = {}) {
      const stackTrace = (0, import_Error.getStackTrace)();
      const DEFAULT_RETRY_OPTIONS = {
        retryDelayInMilliseconds: 100,
        shouldRetryOnError: true,
        timeoutInMilliseconds: 5e3
      };
      const overriddenOptions = { ...DEFAULT_RETRY_OPTIONS, ...retryOptions };
      await runWithTimeout(overriddenOptions.timeoutInMilliseconds, async () => {
        let attempt = 0;
        for (; ; ) {
          attempt++;
          let isSuccess;
          try {
            isSuccess = await fn();
          } catch (error) {
            if (!overriddenOptions.shouldRetryOnError || error.__terminateRetry) {
              throw error;
            }
            (0, import_Error.printError)(error);
            isSuccess = false;
          }
          if (isSuccess) {
            if (attempt > 1) {
              console.debug(`Retry completed successfully after ${attempt.toString()} attempts`);
            }
            return;
          }
          console.debug(`Retry attempt ${attempt.toString()} completed unsuccessfully. Trying again in ${overriddenOptions.retryDelayInMilliseconds.toString()} milliseconds`, {
            fn,
            stackTrace
          });
          await sleep2(overriddenOptions.retryDelayInMilliseconds);
        }
      });
    }
    async function runWithTimeout(timeoutInMilliseconds, fn) {
      let timedOut = false;
      let result = null;
      await Promise.race([run(), timeout2()]);
      if (timedOut) {
        console.error(`Timed out in ${timeoutInMilliseconds.toString()} milliseconds`, { fn });
        throw new Error("Timed out");
      }
      return result;
      async function run() {
        result = await fn();
        timedOut = false;
      }
      async function timeout2() {
        await sleep2(timeoutInMilliseconds);
        timedOut = true;
      }
    }
    async function sleep2(milliseconds) {
      await new Promise((resolve) => setTimeout(resolve, milliseconds));
    }
    async function timeout(timeoutInMilliseconds) {
      await sleep2(timeoutInMilliseconds);
      throw new Error(`Timed out in ${timeoutInMilliseconds.toString()} milliseconds`);
    }
    async function toArray(iter) {
      const arr = [];
      for await (const item of iter) {
        arr.push(item);
      }
      return arr;
    }
  }
});

// node_modules/obsidian-dev-utils/dist/lib/Object.cjs
var require_Object = __commonJS({
  "node_modules/obsidian-dev-utils/dist/lib/Object.cjs"(exports2, module2) {
    (function patchRequireEsmDefault() {
      const __require = require;
      require = Object.assign((id) => {
        const module3 = __require(id);
        return module3.__esModule && module3.default ? module3.default : module3;
      }, __require);
    })();
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var Object_exports = {};
    __export2(Object_exports, {
      assignWithNonEnumerableProperties: () => assignWithNonEnumerableProperties,
      cloneWithNonEnumerableProperties: () => cloneWithNonEnumerableProperties,
      deepEqual: () => deepEqual,
      getNestedPropertyValue: () => getNestedPropertyValue,
      getPrototypeOf: () => getPrototypeOf2,
      nameof: () => nameof,
      setNestedPropertyValue: () => setNestedPropertyValue,
      toJson: () => toJson
    });
    module2.exports = __toCommonJS2(Object_exports);
    var import_Error = require_Error();
    var __process = globalThis["process"] ?? {
      "cwd": () => "/",
      "env": {},
      "platform": "android"
    };
    function assignWithNonEnumerableProperties(target, ...sources) {
      return _assignWithNonEnumerableProperties(target, ...sources);
    }
    function cloneWithNonEnumerableProperties(obj) {
      return Object.create(getPrototypeOf2(obj), Object.getOwnPropertyDescriptors(obj));
    }
    function deepEqual(a, b) {
      if (a === b) {
        return true;
      }
      if (typeof a !== "object" || typeof b !== "object" || a === null || b === null) {
        return false;
      }
      const keysA = Object.keys(a);
      const keysB = Object.keys(b);
      if (keysA.length !== keysB.length) {
        return false;
      }
      const aRecord = a;
      const bRecord = b;
      for (const key of keysA) {
        if (!keysB.includes(key) || !deepEqual(aRecord[key], bRecord[key])) {
          return false;
        }
      }
      return true;
    }
    function getNestedPropertyValue(obj, path) {
      let node = obj;
      const keys = path.split(".");
      for (const key of keys) {
        if (node === void 0) {
          return void 0;
        }
        node = node[key];
      }
      return node;
    }
    function getPrototypeOf2(instance) {
      if (instance === void 0 || instance === null) {
        return instance;
      }
      return Object.getPrototypeOf(instance);
    }
    function nameof(name) {
      return name;
    }
    function setNestedPropertyValue(obj, path, value) {
      const error = new Error(`Property path ${path} not found`);
      let node = obj;
      const keys = path.split(".");
      for (const key of keys.slice(0, -1)) {
        if (node === void 0) {
          throw error;
        }
        node = node[key];
      }
      const lastKey = keys.at(-1);
      if (node === void 0 || lastKey === void 0) {
        throw error;
      }
      node[lastKey] = value;
    }
    function toJson(value, options = {}) {
      const {
        shouldHandleFunctions = false,
        space = 2
      } = options;
      if (!shouldHandleFunctions) {
        return JSON.stringify(value, null, space);
      }
      const functionTexts = [];
      const replacer = (_, value2) => {
        if (typeof value2 === "function") {
          const index = functionTexts.length;
          functionTexts.push(value2.toString());
          return `__FUNCTION_${index.toString()}`;
        }
        return value2;
      };
      let json = JSON.stringify(value, replacer, space);
      json = json.replaceAll(/"__FUNCTION_(\d+)"/g, (_, indexStr) => functionTexts[parseInt(indexStr)] ?? (0, import_Error.throwExpression)(new Error(`Function with index ${indexStr} not found`)));
      return json;
    }
    function _assignWithNonEnumerableProperties(target, ...sources) {
      for (const source of sources) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      }
      const sourcePrototypes = sources.map((source) => getPrototypeOf2(source)).filter((proto) => !!proto);
      if (sourcePrototypes.length > 0) {
        const targetPrototype = _assignWithNonEnumerableProperties({}, getPrototypeOf2(target), ...sourcePrototypes);
        Object.setPrototypeOf(target, targetPrototype);
      }
      return target;
    }
  }
});

// node_modules/obsidian-dev-utils/dist/lib/Function.cjs
var require_Function = __commonJS({
  "node_modules/obsidian-dev-utils/dist/lib/Function.cjs"(exports2, module2) {
    (function patchRequireEsmDefault() {
      const __require = require;
      require = Object.assign((id) => {
        const module3 = __require(id);
        return module3.__esModule && module3.default ? module3.default : module3;
      }, __require);
    })();
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var Function_exports = {};
    __export2(Function_exports, {
      noop: () => noop,
      noopAsync: () => noopAsync,
      omitAsyncReturnType: () => omitAsyncReturnType,
      omitReturnType: () => omitReturnType
    });
    module2.exports = __toCommonJS2(Function_exports);
    function noop() {
    }
    async function noopAsync() {
    }
    function omitAsyncReturnType(fn) {
      return async (...args) => {
        await fn(...args);
      };
    }
    function omitReturnType(fn) {
      return (...args) => {
        fn(...args);
      };
    }
  }
});

// node_modules/obsidian-dev-utils/dist/lib/obsidian/Plugin/PluginSettings.cjs
var require_PluginSettings = __commonJS({
  "node_modules/obsidian-dev-utils/dist/lib/obsidian/Plugin/PluginSettings.cjs"(exports2, module2) {
    (function patchRequireEsmDefault() {
      const __require = require;
      require = Object.assign((id) => {
        const module3 = __require(id);
        return module3.__esModule && module3.default ? module3.default : module3;
      }, __require);
    })();
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var PluginSettings_exports = {};
    __export2(PluginSettings_exports, {
      clonePluginSettings: () => clonePluginSettings,
      loadPluginSettings: () => loadPluginSettings
    });
    module2.exports = __toCommonJS2(PluginSettings_exports);
    function clonePluginSettings(defaultPluginSettingsFactory, settings) {
      return loadPluginSettings(defaultPluginSettingsFactory, settings);
    }
    function loadPluginSettings(defaultPluginSettingsFactory, data) {
      const defaultPluginSettings = defaultPluginSettingsFactory();
      if (data && typeof data === "object") {
        const record = data;
        for (const [key, value] of Object.entries(record)) {
          if (key in defaultPluginSettings) {
            defaultPluginSettings[key] = value;
          }
        }
      }
      return defaultPluginSettings;
    }
  }
});

// node_modules/obsidian-dev-utils/dist/lib/obsidian/Plugin/PluginBase.cjs
var require_PluginBase = __commonJS({
  "node_modules/obsidian-dev-utils/dist/lib/obsidian/Plugin/PluginBase.cjs"(exports2, module2) {
    (function patchRequireEsmDefault() {
      const __require = require;
      require = Object.assign((id) => {
        const module3 = __require(id);
        return module3.__esModule && module3.default ? module3.default : module3;
      }, __require);
    })();
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var PluginBase_exports = {};
    __export2(PluginBase_exports, {
      PluginBase: () => PluginBase2
    });
    module2.exports = __toCommonJS2(PluginBase_exports);
    var import_obsidian2 = require("obsidian");
    var import_Error = require_Error();
    var import_Function = require_Function();
    var import_PluginSettings = require_PluginSettings();
    var __process = globalThis["process"] ?? {
      "cwd": () => "/",
      "env": {},
      "platform": "android"
    };
    var PluginBase2 = class extends import_obsidian2.Plugin {
      /**
       * Gets a copy of the current plugin settings.
       *
       * @returns A copy of the plugin settings.
       */
      get settingsCopy() {
        return (0, import_PluginSettings.clonePluginSettings)(this.createDefaultPluginSettings.bind(this), this.settings);
      }
      /**
       * Gets the AbortSignal used for aborting long-running operations.
       *
       * @returns The abort signal.
       */
      get abortSignal() {
        return this._abortSignal;
      }
      /**
       * Gets the plugin settings.
       *
       * @returns The plugin settings.
       */
      get settings() {
        return this._settings;
      }
      _abortSignal;
      _settings;
      notice;
      /**
       * Called when the plugin is loaded
       */
      async onload() {
        this.register((0, import_Error.registerAsyncErrorEventHandler)(() => {
          this.showNotice("An unhandled error occurred. Please check the console for more information.");
        }));
        await this.loadSettings();
        const pluginSettingsTab = this.createPluginSettingsTab();
        if (pluginSettingsTab) {
          this.addSettingTab(pluginSettingsTab);
        }
        const abortController = new AbortController();
        this._abortSignal = abortController.signal;
        this.register(() => {
          abortController.abort();
        });
        await this.onloadComplete();
        this.app.workspace.onLayoutReady(this.onLayoutReady.bind(this));
      }
      /**
       * Saves the new plugin settings.
       *
       * @param newSettings - The new settings to save.
       * @returns A promise that resolves when the settings are saved.
       */
      async saveSettings(newSettings) {
        this._settings = (0, import_PluginSettings.clonePluginSettings)(this.createDefaultPluginSettings.bind(this), newSettings);
        await this.saveData(this.settings);
      }
      /**
       * Called when the layout is ready. This method can be overridden by subclasses to perform actions once
       * the layout is ready.
       *
       * @returns A promise or void indicating the completion of the layout setup.
       */
      onLayoutReady() {
        (0, import_Function.noop)();
      }
      /**
       * Called when the plugin loading is complete. This method must be implemented by subclasses to perform
       * any additional setup required after loading is complete.
       *
       * @returns A promise or void indicating the completion of the load process.
       */
      onloadComplete() {
        (0, import_Function.noop)();
      }
      /**
       * Parses the provided settings data and returns the parsed `PluginSettings`.
       *
       * @param data - The raw data to be parsed into `PluginSettings`.
       * @returns A promise that resolves to `PluginSettings` or the settings directly.
       */
      parseSettings(data) {
        return (0, import_PluginSettings.loadPluginSettings)(this.createDefaultPluginSettings.bind(this), data);
      }
      /**
       * Displays a notice message to the user.
       *
       * @param message - The message to display.
       */
      showNotice(message) {
        if (this.notice) {
          this.notice.hide();
        }
        this.notice = new import_obsidian2.Notice(`${this.manifest.name}
${message}`);
      }
      /**
       * Loads the plugin settings from the saved data.
       *
       * @returns A promise that resolves when the settings are loaded.
       */
      async loadSettings() {
        const data = await this.loadData();
        this._settings = await this.parseSettings(data);
      }
    };
  }
});

// node_modules/obsidian-typings/dist/implementations.cjs
var require_implementations = __commonJS({
  "node_modules/obsidian-typings/dist/implementations.cjs"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var implementations_exports = {};
    __export2(implementations_exports, {
      CustomArrayDictImpl: () => CustomArrayDictImpl,
      InternalPluginName: () => InternalPluginName2,
      constructApp: () => constructApp,
      constructInternalPlugin: () => constructInternalPlugin,
      constructInternalPlugins: () => constructInternalPlugins,
      constructTFile: () => constructTFile,
      constructTFolder: () => constructTFolder,
      createTFileInstance: () => createTFileInstance,
      createTFolderInstance: () => createTFolderInstance,
      isEmbedCache: () => isEmbedCache,
      isFrontmatterLinkCache: () => isFrontmatterLinkCache,
      isLinkCache: () => isLinkCache,
      isReferenceCache: () => isReferenceCache,
      parentFolderPath: () => parentFolderPath
    });
    module2.exports = __toCommonJS2(implementations_exports);
    function parentFolderPath(path) {
      return path.replace(/\/?[^\/]*$/, "") || "/";
    }
    var import_obsidian2 = require("obsidian");
    function constructTFolder(vault, path) {
      return new import_obsidian2.TFolder(vault, path);
    }
    function createTFolderInstance(vault, path) {
      let folder = vault.getFolderByPath(path);
      if (folder) {
        return folder;
      }
      folder = constructTFolder(vault, path);
      folder.parent = createTFolderInstance(vault, parentFolderPath(path));
      folder.deleted = true;
      return folder;
    }
    var CustomArrayDictImpl = class {
      data = /* @__PURE__ */ new Map();
      add(key, value) {
        let values = this.get(key);
        if (!values) {
          values = [];
          this.data.set(key, values);
        }
        if (!values.includes(value)) {
          values.push(value);
        }
      }
      remove(key, value) {
        const values = this.get(key);
        if (!values) {
          return;
        }
        values.remove(value);
        if (values.length === 0) {
          this.clear(key);
        }
      }
      get(key) {
        return this.data.get(key) || null;
      }
      keys() {
        return Array.from(this.data.keys());
      }
      clear(key) {
        this.data.delete(key);
      }
      clearAll() {
        this.data.clear();
      }
      contains(key, value) {
        return !!this.get(key)?.contains(value);
      }
      count() {
        let ans = 0;
        for (const key in this.keys()) {
          ans += this.get(key)?.length ?? 0;
        }
        return ans;
      }
    };
    var InternalPluginName2 = {
      AudioRecorder: "audio-recorder",
      Backlink: "backlink",
      Bookmarks: "bookmarks",
      Canvas: "canvas",
      CommandPalette: "command-palette",
      DailyNotes: "daily-notes",
      EditorStatus: "editor-status",
      FileExplorer: "file-explorer",
      FileRecovery: "file-recovery",
      GlobalSearch: "global-search",
      Graph: "graph",
      MarkdownImporter: "markdown-importer",
      NoteComposer: "note-composer",
      OutgoingLink: "outgoing-link",
      Outline: "outline",
      PagePreview: "page-preview",
      Properties: "properties",
      Publish: "publish",
      RandomNote: "random-note",
      SlashCommand: "slash-command",
      Slides: "slides",
      Switcher: "switcher",
      Sync: "sync",
      TagPane: "tag-pane",
      Templates: "templates",
      WordCount: "word-count",
      Workspaces: "workspaces",
      ZkPrefixer: "zk-prefixer"
    };
    var import_obsidian22 = require("obsidian");
    function constructTFile(vault, path) {
      return new import_obsidian22.TFile(vault, path);
    }
    function createTFileInstance(vault, path) {
      let file = vault.getFileByPath(path);
      if (file) {
        return file;
      }
      file = constructTFile(vault, path);
      file.parent = createTFolderInstance(vault, parentFolderPath(path));
      file.deleted = true;
      return file;
    }
    function isReferenceCache(reference) {
      return !!reference.position;
    }
    function isEmbedCache(reference) {
      return isReferenceCache(reference) && reference.original[0] === "!";
    }
    function isFrontmatterLinkCache(reference) {
      return !!reference.key;
    }
    function isLinkCache(reference) {
      return isReferenceCache(reference) && reference.original[0] !== "!";
    }
    function constructInternalPlugins(app) {
      return new app.internalPlugins.constructor(app);
    }
    function constructInternalPlugin(app, instance, internalPlugins) {
      const anyPlugin = Object.values(app.internalPlugins.plugins)[0];
      if (!anyPlugin) {
        throw new Error("No internal plugin found");
      }
      return new anyPlugin.constructor(app, instance, internalPlugins);
    }
    var import_obsidian3 = require("obsidian");
    function constructApp(adapter, appId) {
      return new import_obsidian3.App(adapter, appId);
    }
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => RootFolderContextMenu
});
module.exports = __toCommonJS(main_exports);

// node_modules/monkey-around/dist/index.mjs
function around(obj, factories) {
  const removers = Object.keys(factories).map((key) => around1(obj, key, factories[key]));
  return removers.length === 1 ? removers[0] : function() {
    removers.forEach((r) => r());
  };
}
function around1(obj, method, createWrapper) {
  const inherited = obj[method], hadOwn = obj.hasOwnProperty(method), original = hadOwn ? inherited : function() {
    return Object.getPrototypeOf(obj)[method].apply(this, arguments);
  };
  let current = createWrapper(original);
  if (inherited)
    Object.setPrototypeOf(current, inherited);
  Object.setPrototypeOf(wrapper, current);
  obj[method] = wrapper;
  return remove;
  function wrapper(...args) {
    if (current === original && obj[method] === wrapper)
      remove();
    return current.apply(this, args);
  }
  function remove() {
    if (obj[method] === wrapper) {
      if (hadOwn)
        obj[method] = original;
      else
        delete obj[method];
    }
    if (current === original)
      return;
    current = original;
    Object.setPrototypeOf(wrapper, inherited || Function);
  }
}

// src/RootFolderContextMenuPlugin.ts
var import_obsidian = require("obsidian");
var import_Async = __toESM(require_Async(), 1);
var import_Object = __toESM(require_Object(), 1);
var import_PluginBase = __toESM(require_PluginBase(), 1);
var import_implementations = __toESM(require_implementations(), 1);
var RootFolderContextMenu = class extends import_PluginBase.PluginBase {
  fileExplorerPlugin;
  fileExplorerView;
  createDefaultPluginSettings() {
    return {};
  }
  createPluginSettingsTab() {
    return null;
  }
  async onLayoutReady() {
    const fileExplorerPluginInstance = this.app.internalPlugins.getEnabledPluginById(import_implementations.InternalPluginName.FileExplorer);
    if (!fileExplorerPluginInstance) {
      await this.disablePlugin("File Explorer plugin is disabled. Disabling the plugin...");
      return;
    }
    this.fileExplorerPlugin = fileExplorerPluginInstance.plugin;
    await this.initFileExplorerView();
    const viewPrototype = (0, import_Object.getPrototypeOf)(this.fileExplorerView);
    const removeFileExplorerViewPatch = around(viewPrototype, {
      openFileContextMenu: this.applyOpenFileContextMenuPatch.bind(this)
    });
    this.register(removeFileExplorerViewPatch);
    this.register(this.reloadFileExplorer.bind(this));
    await this.reloadFileExplorer();
    const vaultSwitcherEl = document.querySelector(".workspace-drawer-vault-switcher");
    if (vaultSwitcherEl) {
      this.fileExplorerView.files.set(vaultSwitcherEl, this.app.vault.getRoot());
      this.registerDomEvent(vaultSwitcherEl, "contextmenu", async (ev) => {
        const RETRY_DELAY_IN_MILLISECONDS = 100;
        await sleep(RETRY_DELAY_IN_MILLISECONDS);
        document.body.click();
        this.fileExplorerView.openFileContextMenu(ev, vaultSwitcherEl.childNodes[0]);
      });
      const navFilesContainerEl = document.querySelector(".nav-files-container");
      if (navFilesContainerEl) {
        this.registerDomEvent(navFilesContainerEl, "contextmenu", (ev) => {
          if (ev.target !== navFilesContainerEl) {
            return;
          }
          this.fileExplorerView.openFileContextMenu(ev, vaultSwitcherEl.childNodes[0]);
        });
      }
    }
  }
  applyOpenFileContextMenuPatch(next) {
    return function(event, fileItemElement) {
      if (!fileItemElement.parentElement) {
        return;
      }
      const file = this.files.get(fileItemElement.parentElement);
      if (!(file instanceof import_obsidian.TFolder) || !file.isRoot()) {
        next.call(this, event, fileItemElement);
        return;
      }
      file.isRoot = () => false;
      next.call(this, event, fileItemElement);
      file.isRoot = () => true;
    };
  }
  async disablePlugin(message) {
    console.error(message);
    new import_obsidian.Notice(message);
    await this.app.plugins.disablePlugin(this.manifest.id);
  }
  async initFileExplorerView() {
    try {
      await (0, import_Async.retryWithTimeout)(() => {
        const fileExplorerLeaf = this.app.workspace.getLeavesOfType(import_implementations.InternalPluginName.FileExplorer)[0];
        if (fileExplorerLeaf) {
          console.debug("FileExplorerLeaf is initialized");
          this.fileExplorerView = fileExplorerLeaf.view;
          return true;
        }
        console.debug("FileExplorerLeaf is not initialized yet. Repeating...");
        return false;
      });
    } catch (e) {
      console.error(e);
      await this.disablePlugin("Could not initialize FileExplorerView. Disabling the plugin...");
    }
  }
  async reloadFileExplorer() {
    console.log("Disabling File Explorer plugin");
    this.fileExplorerPlugin.disable();
    console.log("Enabling File Explorer plugin");
    await this.fileExplorerPlugin.enable();
    await this.initFileExplorerView();
  }
};

/* nosourcemap */