/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
If you want to view the source, please visit the github repository
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ImgurPreviewPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");
var import_view = require("@codemirror/view");

// src/settings/settings.ts
var DEFAULT_SETTINGS = {
  defaultMaxWidth: 300,
  defaultMaxHeight: 300,
  enableCustomMode: false,
  rememberLastSize: false
};

// src/settings/settingsTab.ts
var import_obsidian = require("obsidian");
var ImgurPreviewSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Imgur Preview Settings" });
    new import_obsidian.Setting(containerEl).setName("Default Maximum Width").setDesc("Maximum width of the preview image in pixels").addText((text) => text.setPlaceholder("300").setValue(this.plugin.settings.defaultMaxWidth.toString()).onChange(async (value) => {
      const numValue = Number(value);
      if (!isNaN(numValue) && numValue > 0) {
        this.plugin.settings.defaultMaxWidth = numValue;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Default Maximum Height").setDesc("Maximum height of the preview image in pixels").addText((text) => text.setPlaceholder("300").setValue(this.plugin.settings.defaultMaxHeight.toString()).onChange(async (value) => {
      const numValue = Number(value);
      if (!isNaN(numValue) && numValue > 0) {
        this.plugin.settings.defaultMaxHeight = numValue;
        await this.plugin.saveSettings();
      }
    }));
    containerEl.createEl("p", {
      text: "Tip: You can also use Ctrl + Mouse Wheel to zoom the preview while hovering over a link."
    });
    new import_obsidian.Setting(containerEl).setName("Remember Last Size").setDesc("When enabled, new tooltips will open at the same size as the last viewed image. When disabled, tooltips always open at default size.").addToggle((toggle) => toggle.setValue(this.plugin.settings.rememberLastSize).onChange(async (value) => {
      this.plugin.settings.rememberLastSize = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", {
      text: "Beta Features",
      cls: "imgur-preview-beta-heading"
    });
    containerEl.createEl("p", {
      text: "\u26A0\uFE0F The following features are experimental and may change significantly in future updates.",
      cls: "imgur-preview-beta-warning"
    });
    new import_obsidian.Setting(containerEl).setName("Enable Custom Mode (Beta)").setDesc("Enables the custom mode toggle in the status bar. Custom mode functionality is still in development.").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableCustomMode).onChange(async (value) => {
      this.plugin.settings.enableCustomMode = value;
      await this.plugin.saveSettings();
    }));
  }
};

// src/features/tooltip/tooltip.ts
var TooltipManager = class {
  constructor(plugin, maxWidth, maxHeight) {
    this.currentTooltipLink = null;
    this.isMouseOverTooltip = false;
    this.lastLinkRect = null;
    this.tooltipPosition = null;
    this.currentScale = 1;
    this.lastUsedScale = 1;
    this.isDragging = false;
    this.dragStartX = 0;
    this.dragStartY = 0;
    this.tooltipStartX = 0;
    this.tooltipStartY = 0;
    this.isPositionLocked = false;
    this.initialWidth = 0;
    this.initialHeight = 0;
    this.plugin = plugin;
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this.tooltipElement = document.createElement("div");
    this.tooltipElement.className = "imgur-preview-tooltip";
    this.setupTooltipStyles();
    this.setupTooltipEventListeners();
    document.body.appendChild(this.tooltipElement);
  }
  setupTooltipStyles() {
    this.tooltipElement.style.position = "fixed";
    this.tooltipElement.style.zIndex = "1000";
    this.tooltipElement.style.display = "none";
    this.tooltipElement.style.backgroundColor = "var(--background-primary)";
    this.tooltipElement.style.border = "1px solid var(--background-modifier-border)";
    this.tooltipElement.style.borderRadius = "5px";
    this.tooltipElement.style.padding = "10px";
    this.tooltipElement.style.boxShadow = "0 2px 5px rgba(0,0,0,0.2)";
    this.tooltipElement.style.cursor = "pointer";
    this.tooltipElement.style.overflow = "hidden";
  }
  setupTooltipEventListeners() {
    this.tooltipElement.addEventListener("mouseenter", () => {
      this.isMouseOverTooltip = true;
      if (!this.isPositionLocked) {
        setTimeout(() => {
          if (!this.isPositionLocked) {
            this.hideTooltip();
          }
        }, 3e3);
      }
    });
    this.tooltipElement.addEventListener("mouseleave", () => {
      this.isMouseOverTooltip = false;
      if (!this.isPositionLocked) {
        this.hideTooltip();
      }
    });
    this.wheelListener = (e) => {
      if (!e.ctrlKey && !this.isPositionLocked) {
        this.hideTooltip();
      }
    };
    document.addEventListener("wheel", this.wheelListener);
    this.tooltipElement.addEventListener("mousedown", (e) => {
      e.preventDefault();
      e.stopPropagation();
      this.isDragging = true;
      this.dragStartX = e.clientX;
      this.dragStartY = e.clientY;
      const rect = this.tooltipElement.getBoundingClientRect();
      this.tooltipStartX = rect.left;
      this.tooltipStartY = rect.top;
      this.tooltipElement.style.cursor = "pointer";
    });
    document.addEventListener("mousemove", (e) => {
      if (this.isDragging) {
        const deltaX = e.clientX - this.dragStartX;
        const deltaY = e.clientY - this.dragStartY;
        this.tooltipElement.style.left = `${this.tooltipStartX + deltaX}px`;
        this.tooltipElement.style.top = `${this.tooltipStartY + deltaY}px`;
      }
    });
    document.addEventListener("mouseup", () => {
      if (this.isDragging) {
        this.isDragging = false;
        this.isPositionLocked = true;
        this.tooltipElement.style.cursor = "pointer";
      }
    });
    this.tooltipElement.addEventListener("dblclick", (e) => {
      e.preventDefault();
      e.stopPropagation();
      this.hideTooltip(true);
    });
  }
  showTooltip(imgLink, coords) {
    if (this.currentTooltipLink === imgLink)
      return;
    this.currentTooltipLink = imgLink;
    this.tooltipPosition = coords;
    const linkElement = document.elementFromPoint(coords.x, coords.y);
    if (linkElement) {
      this.lastLinkRect = linkElement.getBoundingClientRect();
    }
    this.tooltipElement.innerHTML = "";
    this.currentScale = this.plugin.settings.rememberLastSize ? this.lastUsedScale : 1;
    const img = document.createElement("img");
    img.style.maxWidth = `${this.maxWidth}px`;
    img.style.maxHeight = `${this.maxHeight}px`;
    img.style.transition = "transform 0.1s ease-out";
    img.style.transformOrigin = "top left";
    img.style.pointerEvents = "none";
    const directImageLink = this.getDirectImageLink(imgLink);
    img.src = directImageLink;
    img.onload = () => {
      const aspectRatio = img.naturalWidth / img.naturalHeight;
      let width = img.naturalWidth;
      let height = img.naturalHeight;
      if (width > this.maxWidth) {
        width = this.maxWidth;
        height = width / aspectRatio;
      }
      if (height > this.maxHeight) {
        height = this.maxHeight;
        width = height * aspectRatio;
      }
      img.style.width = `${width}px`;
      img.style.height = `${height}px`;
      this.initialWidth = width;
      this.initialHeight = height;
    };
    this.tooltipElement.appendChild(img);
    this.positionTooltip(coords.x, coords.y);
    this.tooltipElement.style.display = "block";
  }
  getDirectImageLink(link) {
    if (link.match(/\.(jpe?g|png|gif|svg|webp)$/i)) {
      return link;
    }
    if (link.includes("imgur.com")) {
      const imgurId = link.split("/").pop();
      if (!imgurId)
        return link;
      if (imgurId.includes(".")) {
        return link;
      }
      return `https://i.imgur.com/${imgurId}.jpg`;
    }
    if (link.startsWith("app://")) {
      return link;
    }
    return link;
  }
  positionTooltip(x, y) {
    const padding = 10;
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    let tooltipX = x;
    let tooltipY = y + padding;
    const tooltipRect = this.tooltipElement.getBoundingClientRect();
    if (tooltipX + tooltipRect.width > viewportWidth - padding) {
      tooltipX = viewportWidth - tooltipRect.width - padding;
    }
    if (tooltipY + tooltipRect.height > viewportHeight - padding) {
      tooltipY = y - tooltipRect.height - padding;
    }
    this.tooltipElement.style.left = `${tooltipX}px`;
    this.tooltipElement.style.top = `${tooltipY}px`;
  }
  hideTooltip(force = false) {
    if (force || !this.isPositionLocked) {
      if (this.plugin.settings.rememberLastSize) {
        this.lastUsedScale = this.currentScale;
      }
      this.tooltipElement.style.display = "none";
      this.currentTooltipLink = null;
      this.lastLinkRect = null;
      this.tooltipPosition = null;
      this.isPositionLocked = false;
    }
  }
  handleZoom(deltaY) {
    const zoomFactor = 0.1;
    const minScale = 0.5;
    const maxScale = 3;
    const zoomDelta = deltaY > 0 ? -zoomFactor : zoomFactor;
    const newScale = Math.max(minScale, Math.min(maxScale, this.currentScale + zoomDelta));
    if (newScale !== this.currentScale) {
      this.currentScale = newScale;
      const img = this.tooltipElement.querySelector("img");
      if (img) {
        img.style.transform = `scale(${newScale})`;
        const padding = 20;
        const scaledWidth = this.initialWidth * newScale;
        const scaledHeight = this.initialHeight * newScale;
        const container = img.parentElement;
        if (container) {
          container.style.width = `${scaledWidth + padding}px`;
          container.style.height = `${scaledHeight + padding}px`;
          container.style.transition = "width 0.1s ease-out, height 0.1s ease-out";
        }
      }
    }
  }
  getCurrentTooltipLink() {
    return this.currentTooltipLink;
  }
  getIsMouseOverTooltip() {
    return this.isMouseOverTooltip;
  }
  getLastLinkRect() {
    return this.lastLinkRect;
  }
  getTooltipPosition() {
    return this.tooltipPosition;
  }
  getTooltipElement() {
    return this.tooltipElement;
  }
  updateSettings(maxWidth, maxHeight) {
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    if (this.currentTooltipLink) {
      const img = this.tooltipElement.querySelector("img");
      if (img) {
        img.style.maxWidth = `${maxWidth}px`;
        img.style.maxHeight = `${maxHeight}px`;
      }
    }
  }
  destroy() {
    document.removeEventListener("wheel", this.wheelListener);
    this.tooltipElement.remove();
  }
};

// src/features/tooltip/mouseUtils.ts
function isMouseMovingTowardsTooltip(mouseX, mouseY, linkRect, tooltipRect, tooltipPosition) {
  const linkCenterX = linkRect.left + linkRect.width / 2;
  const linkCenterY = linkRect.top + linkRect.height / 2;
  const tooltipCenterX = tooltipRect.left + tooltipRect.width / 2;
  const tooltipCenterY = tooltipRect.top + tooltipRect.height / 2;
  const linkToTooltipX = tooltipCenterX - linkCenterX;
  const linkToTooltipY = tooltipCenterY - linkCenterY;
  const linkToMouseX = mouseX - linkCenterX;
  const linkToMouseY = mouseY - linkCenterY;
  const dotProduct = linkToTooltipX * linkToMouseX + linkToTooltipY * linkToMouseY;
  const linkToTooltipMagnitude = Math.sqrt(linkToTooltipX * linkToTooltipX + linkToTooltipY * linkToTooltipY);
  const linkToMouseMagnitude = Math.sqrt(linkToMouseX * linkToMouseX + linkToMouseY * linkToMouseY);
  const angle = Math.acos(dotProduct / (linkToTooltipMagnitude * linkToMouseMagnitude));
  const angleInDegrees = angle * (180 / Math.PI);
  return angleInDegrees < 90;
}

// src/main.ts
var ImgurPreviewPlugin = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    this.hoverTimeout = null;
    this.hideTimeoutId = null;
    this.currentMode = "default";
  }
  async onload() {
    console.log("Loading Imgur Preview plugin");
    await this.loadSettings();
    this.statusBarItem = this.addStatusBarItem();
    this.statusBarItem.addClass("mod-clickable");
    this.updateStatusBar();
    this.updateStatusBarVisibility();
    this.statusBarItem.onclick = () => {
      this.currentMode = this.currentMode === "default" ? "custom" : "default";
      this.updateStatusBar();
      this.tooltipManager.hideTooltip();
    };
    this.tooltipManager = new TooltipManager(
      this,
      this.settings.defaultMaxWidth,
      this.settings.defaultMaxHeight
    );
    this.addSettingTab(new ImgurPreviewSettingTab(this.app, this));
    this.registerDomEvent(document, "wheel", (e) => {
      if (!this.tooltipManager.getCurrentTooltipLink())
        return;
      if (e.ctrlKey) {
        e.preventDefault();
        this.tooltipManager.handleZoom(e.deltaY);
      }
    });
    this.registerEditorExtension([
      import_view.EditorView.domEventHandlers({
        mouseover: this.handleMouseOver.bind(this),
        mouseout: this.handleMouseOut.bind(this)
      })
    ]);
  }
  onunload() {
    console.log("Unloading Imgur Preview plugin");
    this.tooltipManager.destroy();
  }
  updateStatusBarVisibility() {
    if (this.settings.enableCustomMode) {
      this.statusBarItem.style.display = "flex";
    } else {
      this.statusBarItem.style.display = "none";
      if (this.currentMode === "custom") {
        this.currentMode = "default";
      }
    }
  }
  updateStatusBar() {
    const icon = this.currentMode === "default" ? "image" : "rocket";
    this.statusBarItem.empty();
    const iconContainer = this.statusBarItem.createSpan({ cls: "imgur-preview-status-icon" });
    (0, import_obsidian2.setIcon)(iconContainer, icon);
    this.statusBarItem.setAttribute(
      "aria-label",
      this.currentMode === "default" ? "Click to enter custom mode (Beta)" : "Click to return to default mode"
    );
  }
  async handleMouseOver(event, view) {
    const target = event.target;
    if (!target.matches(".cm-underline, .cm-link:not(.cm-formatting-link)")) {
      return;
    }
    if (this.hoverTimeout) {
      clearTimeout(this.hoverTimeout);
      this.hoverTimeout = null;
    }
    const pos = view.posAtCoords({ x: event.clientX, y: event.clientY });
    if (pos === null)
      return;
    const line = view.state.doc.lineAt(pos);
    const lineText = line.text;
    console.log("Hover detected at position:", pos);
    console.log("Line text:", lineText);
    const linkRegex = /\[([^\]]+)\]\((.*?)\)/g;
    let match;
    let foundLink = null;
    while ((match = linkRegex.exec(lineText)) !== null) {
      const [fullMatch, linkText, path] = match;
      if (!path.match(/\.(jpe?g|png|gif|svg|webp)$/i) && !path.match(/^https?:\/\/(?:i\.)?imgur\.com\//)) {
        continue;
      }
      const linkTextStart = match.index + 1;
      const linkTextEnd = linkTextStart + linkText.length;
      if (pos >= line.from + linkTextStart && pos <= line.from + linkTextEnd) {
        if (!path.startsWith("http")) {
          const imageFile = this.app.metadataCache.getFirstLinkpathDest(decodeURIComponent(path), "");
          foundLink = imageFile ? this.app.vault.getResourcePath(imageFile) : path;
        } else {
          foundLink = path;
        }
        console.log("Found image link:", foundLink);
        break;
      }
    }
    if (foundLink && foundLink !== this.tooltipManager.getCurrentTooltipLink()) {
      this.hoverTimeout = setTimeout(() => {
        this.tooltipManager.showTooltip(foundLink, { x: event.clientX, y: event.clientY });
      }, 100);
    }
  }
  handleMouseOut(event) {
    if (this.hoverTimeout) {
      clearTimeout(this.hoverTimeout);
      this.hoverTimeout = null;
    }
    const lastLinkRect = this.tooltipManager.getLastLinkRect();
    const tooltipPosition = this.tooltipManager.getTooltipPosition();
    if (!lastLinkRect || !tooltipPosition) {
      this.tooltipManager.hideTooltip();
      return;
    }
    const mouseX = event.clientX;
    const mouseY = event.clientY;
    const tooltipRect = this.tooltipManager.getTooltipElement().getBoundingClientRect();
    const isMovingTowards = isMouseMovingTowardsTooltip(
      mouseX,
      mouseY,
      lastLinkRect,
      tooltipRect,
      tooltipPosition
    );
    if (isMovingTowards) {
      if (this.hideTimeoutId) {
        clearTimeout(this.hideTimeoutId);
      }
      this.hideTimeoutId = setTimeout(() => {
        if (!this.tooltipManager.getIsMouseOverTooltip()) {
          this.tooltipManager.hideTooltip();
        }
      }, 300);
    } else {
      this.tooltipManager.hideTooltip();
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.tooltipManager.updateSettings(
      this.settings.defaultMaxWidth,
      this.settings.defaultMaxHeight
    );
    this.updateStatusBarVisibility();
  }
};
